#!/bin/bash
export LS_OPTIONS='--color=auto'
eval "$(dircolors)"
alias ls='ls $LS_OPTIONS'
alias ll='ls $LS_OPTIONS -l'
alias treel='tree -L 2 --filesfirst -F'
alias diff='diff -u --color'

alias grep='grep --color'

alias sudo='sudo '
alias tailf='tail -f'

alias gldoc='git log --decorate --oneline --color'
alias gll='git log --pretty=format:"%C(yellow)%h %Creset%s%Cblue [%ae] (%ad)" --decorate --numstat --date=relative --shortstat'
alias grpo='git remote prune origin'

# this is now a script
#alias gry='git review -y'

# Comment for now. Podman tags local images as localhost/<image>:latest
# and plenty of my kubernetes manifests can't work with that
#alias docker='podman'

# fuzzy grep search
# this shows all files in a fzf preview panel with grep search context
fgs() {
    if [ "$1" == "" ] ; then
        return 1
    fi

    grep --ignore-case --recursive --files-with-matches --only-matching --binary-files=without-match --no-messages "$1" * \
        | fzf --preview "grep --ignore-case --color=always --context 3 '$1' {}"
}

# fuzzy git grep search
fggs() {
    if [ "$1" == "" ] ; then
        return 1
    fi

    git grep --ignore-case --no-index -I --full-name --files-with-matches "$1" \
        | fzf --preview "git grep -h --line-number --ignore-case --color=always --context 3 '$1' {}"
}

# fuzzy file browser
ffb() {
    dir="${1:-.}"
    find ${dir} -type f | fzf --preview "pygmentize -g {}"
}

# fuzzy tree browser
ftb() {
    dir="${1:-.}"
    tree -C -f --prune --noreport ${dir} | fzf --no-sort --ansi --preview "pygmentize -g {-1}"
}

# fuzzy cd
fcd() {
    dir="${1:-.}"
    if [ ! -d "${dir}" ] ; then
        return 1
    fi
    cd $(find ${dir} -type d | fzf)
}

# fuzzy file browser for anything
ffba() {
    if [ "$#" == "0" ] ; then
        return 1
    fi

    result=$(ffb)
    if [ "$result" == "" ] ; then
        return 1
    fi

    this_command="ffba ${@}"
    next_command="${@} ${result}"

    # leave traces of what just happened
    # 1) echo the command we will execute for real
    # 2) save in the history this very call (this function call)
    # 3) save in the history the next command, so the keyboard's arrow up finds it
    echo "${next_command}"
    history -s "${this_command}"
    history -s "${next_command}"

    # execute the actual command
    eval ${next_command}
}

# fuzzy file search then nano
alias fnano='ffba nano'

# fuzzy grep then nano
fgnano() {
    if [ "$1" == "" ] ; then
        return 1
    fi

    if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" == "true" ] ; then
        fuzzy_command="fggs"
    else
        fuzzy_command="fgs"
    fi

    result=$(${fuzzy_command} "${@}")
    if [ "$result" == "" ] ; then
        return 1
    fi

    this_command="fgnano ${@}"
    next_command="nano ${result}"

    # leave traces of what just happened
    # 1) echo the command we will execute for real
    # 2) save in the history this very call (this function call)
    # 3) save in the history the next command, so the keyboard's arrow up finds it
    echo "${next_command}"
    history -s "${this_command}"
    history -s "${next_command}"

    # execute the actual command
    eval ${next_command}
}

# fuzzy git log
fgl() {
    if [ "$(git rev-parse --is-inside-work-tree)" != "true" ] ; then
        return 1
    fi

    this_command="fgl"
    cmd_git_log="git log --decorate --oneline --color '${1:-.}'"
    cmd_fzf='fzf --no-sort --layout=reverse-list --ansi --preview "git show --patch-with-stat --color {1}"'
    command="${cmd_git_log} | ${cmd_fzf}"
    result=$(eval ${command})
    if [ "$result" == "" ] ; then
        return 1
    fi

    git_hash=$(awk -F' ' '{print $1}' <<< ${result})
    next_command="git show --patch-with-stat ${git_hash}"

    # leave traces of what just happened
    # 1) echo the command we will execute for real
    # 2) save in the history this very call (this function call)
    # 3) save in the history the next command, so the keyboard's arrow up finds it
    echo "${next_command}"
    history -s "${this_command}"
    history -s "${next_command}"

    # execute the actual command
    eval ${next_command}
}
